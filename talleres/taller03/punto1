

/**
 * 
 * 
 * @author Manuela Valencia, Laura SÃ¡nchez 
 
 
/**
 *

 */
public class Queens {    

    public static boolean canPlaceQueen(int r, int c,int []tablero) {
        /**
         * Returns TRUE if a queen can be placed in row r and column c.
         * Otherwise it returns FALSE. x[] is a global array whose first (r-1)
         * values have been set.
         */
        for (int i = 0; i < r; i++) {
            if (tablero[i] == c || (i - r) == (tablero[i] - c) ||(i - r) == (c - tablero[i])) 
            {
                return false;
            }
        }
        return true;
    }

    public static void printQueens(int[] x) {
        int N = x.length;
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                if (x[i] == j) {
                    System.out.print("Q ");
                } else {
                    System.out.print("* ");
                }
            }
            System.out.println();
        }
        System.out.println();
    }
      public static int contador=0;  
    public static int placeNqueens(int r, int n,int [] tablero) {
        /**
         * Using backtracking this method prints all possible placements of n
         * queens on an n x n chessboard so that they are non-attacking.
         */
        
        for (int c = 0; c < n; c++) {
            if (canPlaceQueen(r, c,tablero)) {
                tablero[r] = c;
                if (r == n - 1) {
                    contador++;
                } else {
                    placeNqueens(r + 1, n,tablero);
                }
            }
        }
        return contador;
    }
    

    public static int callplaceNqueens (int n) {
       int contador=0;
         int[] tablero= new int[n];
       contador=contador + placeNqueens(0, tablero.length,tablero);
        return contador;
    }

}
